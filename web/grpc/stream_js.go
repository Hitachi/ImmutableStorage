// +build js,wasm

package grpc

import (
	"bytes"
	"context"
	"encoding/binary"
	"io"
	"io/ioutil"
	"net/http"

	"google.golang.org/protobuf/proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

// ClientStream defines the client-side behavior of a streaming RPC.
//
// All errors returned from ClientStream methods are compatible with the
// status package.
type ClientStream interface {
	// Header returns the header metadata received from the server if there
	// is any. It blocks if the metadata is not ready to read.
	Header() (metadata.MD, error)
	// Trailer returns the trailer metadata from the server, if there is any.
	// It must only be called after stream.CloseAndRecv has returned, or
	// stream.Recv has returned a non-nil error (including io.EOF).
	Trailer() metadata.MD
	// CloseSend closes the send direction of the stream. It closes the stream
	// when non-nil error is met. It is also not safe to call CloseSend
	// concurrently with SendMsg.
	CloseSend() error
	// Context returns the context for this stream.
	//
	// It should not be called until after Header or RecvMsg has returned. Once
	// called, subsequent client-side retries are disabled.
	Context() context.Context
	// SendMsg is generally called by generated code. On error, SendMsg aborts
	// the stream. If the error was generated by the client, the status is
	// returned directly; otherwise, io.EOF is returned and the status of
	// the stream may be discovered using RecvMsg.
	//
	// SendMsg blocks until:
	//   - There is sufficient flow control to schedule m with the transport, or
	//   - The stream is done, or
	//   - The stream breaks.
	//
	// SendMsg does not wait until the message is received by the server. An
	// untimely stream closure may result in lost messages. To ensure delivery,
	// users should ensure the RPC completed successfully using RecvMsg.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not safe
	// to call SendMsg on the same stream in different goroutines. It is also
	// not safe to call CloseSend concurrently with SendMsg.
	SendMsg(m interface{}) error
	// RecvMsg blocks until it receives a message into m or the stream is
	// done. It returns io.EOF when the stream completes successfully. On
	// any other error, the stream is aborted and the error contains the RPC
	// status.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not
	// safe to call RecvMsg on the same stream in different goroutines.
	RecvMsg(m interface{}) error
}

// ServerStream defines the server-side behavior of a streaming RPC.
//
// All errors returned from ServerStream methods are compatible with the
// status package.
type ServerStream interface {
	// SetHeader sets the header metadata. It may be called multiple times.
	// When call multiple times, all the provided metadata will be merged.
	// All the metadata will be sent out when one of the following happens:
	//  - ServerStream.SendHeader() is called;
	//  - The first response is sent out;
	//  - An RPC status is sent out (error or success).
	SetHeader(metadata.MD) error
	// SendHeader sends the header metadata.
	// The provided md and headers set by SetHeader() will be sent.
	// It fails if called multiple times.
	SendHeader(metadata.MD) error
	// SetTrailer sets the trailer metadata which will be sent with the RPC status.
	// When called more than once, all the provided metadata will be merged.
	SetTrailer(metadata.MD)
	// Context returns the context for this stream.
	Context() context.Context
	// SendMsg sends a message. On error, SendMsg aborts the stream and the
	// error is returned directly.
	//
	// SendMsg blocks until:
	//   - There is sufficient flow control to schedule m with the transport, or
	//   - The stream is done, or
	//   - The stream breaks.
	//
	// SendMsg does not wait until the message is received by the client. An
	// untimely stream closure may result in lost messages.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not safe
	// to call SendMsg on the same stream in different goroutines.
	SendMsg(m interface{}) error
	// RecvMsg blocks until it receives a message into m or the stream is
	// done. It returns io.EOF when the client has performed a CloseSend. On
	// any non-EOF error, the stream is aborted and the error contains the
	// RPC status.
	//
	// It is safe to have a goroutine calling SendMsg and another goroutine
	// calling RecvMsg on the same stream at the same time, but it is not
	// safe to call RecvMsg on the same stream in different goroutines.
	RecvMsg(m interface{}) error
}

// StreamHandler defines the handler called by gRPC server to complete the
// execution of a streaming RPC. If a StreamHandler returns an error, it
// should be produced by the status package, or else gRPC will use
// codes.Unknown as the status code and err.Error() as the status message
// of the RPC.
type StreamHandler func(srv interface{}, stream ServerStream) error

// StreamDesc represents a streaming RPC service's method specification.
type StreamDesc struct {
	StreamName string
	Handler    StreamHandler

	// At least one of these is true.
	ServerStreams bool
	ClientStreams bool
}

type methodHandler func(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor UnaryServerInterceptor) (interface{}, error)

// MethodDesc represents an RPC service's method specification.
type MethodDesc struct {
	MethodName string
	Handler    methodHandler
}

// ServiceDesc represents an RPC service's specification.
type ServiceDesc struct {
	ServiceName string
	// The pointer to the service interface. Used to check whether the user
	// provided implementation satisfies the interface requirements.
	HandlerType interface{}
	Methods     []MethodDesc
	Streams     []StreamDesc
	Metadata    interface{}
}

type clientStream struct {
	ctx   context.Context
	req   *http.Request
	errCh chan error
	msgCh chan []byte
}

func (cc *ClientConn) NewStream(ctx context.Context, desc *StreamDesc, method string, opts ...CallOption) (ClientStream, error) {
        if desc.ClientStreams {
                return nil, status.Error(codes.Unimplemented, "client-side streaming is not supported by grpc-web")
        }

        endpoint := cc.target + method
        if cc.target == "" {
                endpoint = method
        }

        return newStream(ctx, endpoint)
}

func newStream(ctx context.Context, endpoint string) (*clientStream, error) {
	cs := &clientStream{
		ctx: ctx,
	}

	req, err := http.NewRequest(
		"POST",
		endpoint,
		nil,
	)
	if err != nil {
		return nil, status.New(codes.Unavailable, err.Error()).Err()
	}

	cs.req = req.WithContext(ctx)
//	println("log: newStream: done")
	return cs, nil
}

// NewClientStream is a wrapper for ClientConn.NewStream.
func NewClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (ClientStream, error) {
	return cc.NewStream(ctx, desc, method, opts...)
}

func (c *clientStream) Header() (metadata.MD, error) {
	return nil, nil
}

func (c *clientStream) Trailer() metadata.MD {
	return nil
}

func (c *clientStream) Context() context.Context {
	return c.ctx
}

func (c *clientStream) RecvMsg(reply interface{}) error {
	select {
	case <-c.ctx.Done():
		return c.ctx.Err()
	case err := <-c.errCh:
		return err
	case msg, ok := <-c.msgCh:
		if !ok {
			return io.EOF
		}
		err := proto.Unmarshal(msg, reply.(proto.Message))
		return err
	}
}

func (c *clientStream) SendMsg(req interface{}) error {
	msg, err := proto.Marshal(req.(proto.Message))
	if err != nil {
		return status.Error(codes.Internal, err.Error())
	}

	bufHeader := make([]byte, 5)

	// Write length of b into buf
	binary.BigEndian.PutUint32(bufHeader[1:], uint32(len(msg)))

	c.req.Body = ioutil.NopCloser(bytes.NewBuffer(append(bufHeader, msg...)))
	addHeaders(c.req)

	resp, err := http.DefaultClient.Do(c.req)
	if err != nil {
		return status.Error(codes.Unavailable, err.Error())
	}

	st := statusFromHeaders(resp.Header)
	if st.Code() != codes.OK {
		resp.Body.Close()
		return st.Err()
	}

	c.errCh = make(chan error, 1)
	c.msgCh = make(chan []byte, 1)

	// Read response asynchronously
	go func() {
		defer resp.Body.Close()

		msgHeader := make([]byte, 5)
		for {
			_, err := io.ReadFull(resp.Body, msgHeader)
			if err != nil {
				c.errCh <- status.Error(codes.Internal, err.Error())
				return
			}

			// 1 in MSB signifies that this is the trailer. Break loop.
			// https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md#protocol-differences-vs-grpc-over-http2
			if msgHeader[0]>>7 == 1 {
				break
			}

			msgLen := binary.BigEndian.Uint32(msgHeader[1:])

			msg := make([]byte, msgLen)
			_, err = io.ReadFull(resp.Body, msg)
			if err != nil {
				c.errCh <- status.Error(codes.Internal, err.Error())
				return
			}
			c.msgCh <- msg
		}

		if msgHeader[0]&1 == 0 {
			trailers, err := readTrailers(resp.Body)
			if err != nil {
				c.errCh <- status.Error(codes.Internal, err.Error())
				return
			}
			st = statusFromHeaders(trailers)
		} else {
			// TODO(johanbrandhorst): Support compressed trailers
		}

		if st.Code() != codes.OK {
			c.errCh <- st.Err()
			return
		}

		close(c.msgCh)
	}()

	return nil
}

func (c *clientStream) CloseSend() error {
	return nil
}
